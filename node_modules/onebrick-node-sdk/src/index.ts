import { TransactionWorker } from './core/worker/transactionWorker';
import { StatementWorker } from './core/worker/statementWorker';
import { InsightWorker } from './core/worker/insightWorker';
import { EcommerceDataWorker } from './core/worker/ecommerceDataWorker';
import { AccountDataWorker } from './core/worker/accountWorker';
import { EmploymentDataWorker } from "./core/worker/employmentDataWorker";
import { Configuration } from "./core/util/configuration";
import {
  IInstitutionPayload,
  InstitutionWorker,
} from "./core/worker/institutionWorker";
import { AccessTokenWorker } from "./core/worker/accessTokenWorker";
import { BankWorker } from "./core/worker/bankWorker";
import { IncomeVerificationWorker } from "./core/worker/incomeVerification";
import { EWalletWorker } from "./core/worker/eWalletWorker";
import { EcommerceWorker } from "./core/worker/ecommerceWorker";
import { CorporateBankingWorker } from "./core/worker/corporateBankingWorker";

export enum ENVIRONMENT {
  SANBOX = 0,
  PRODUCTION = 1,
}

export interface IBrickSDK {
  listInstitution(): Promise<any>;
  requestAccessToken(): Promise<any>;
  requestAuthentication(): Promise<any>;
  authenticatteWithMFABank(): Promise<any>;
}

export class BrickSDK implements IBrickSDK {
  configuration: Configuration;
  ewalletWorker?: EWalletWorker;
  transactionWorker?:TransactionWorker;
  statementWorker?:StatementWorker
  insightWorker?: InsightWorker
  employmentDataWorker?: EmploymentDataWorker;
  accountDataWorker?:AccountDataWorker;
  ecommerceDataWorker?:EcommerceDataWorker
  institutionWorker?: InstitutionWorker;
  accesstokenWorker?: AccessTokenWorker;
  bankWorker?: BankWorker;
  ecommerceWorker?: EcommerceWorker;
  incomeVerification?: IncomeVerificationWorker;
  corporateBankingWorker?: CorporateBankingWorker;
  constructor(
    clientKey?: string,
    clientSecret?: string,
    environment?: number,
    name?: string,
    redirectURL?: string
  ) {
    this.configuration = new Configuration(
      clientKey,
      clientSecret,
      environment,
      name,
      redirectURL
    );
  }

  authenticateCorporateBanking(
    institutionId: number,
    username: string,
    password: string
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      this.corporateBankingWorker = new CorporateBankingWorker(
        this.configuration,
        institutionId
      );
      this.corporateBankingWorker
        .authenticateUser(username, password)
        .then((data: any) => {
          return resolve(data);
        })
        .catch((err: Error) => {
          return reject(err);
        });
    });
  }
  rerequestAuthenticateionCoorporateBanking(
    institutionId: number,
    userId: string,
    corporateId: string,
    token: string
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      this.corporateBankingWorker = new CorporateBankingWorker(
        this.configuration,
        institutionId
      );
      this.corporateBankingWorker
        .reauthenticateUser(userId, corporateId, token)
        .then((data: any) => {
          return resolve(data);
        })
        .catch((err: Error) => {
          return reject(err);
        });
    });
  }
  reauthenticateWithOTPEwalllet(
    otp: string,
    institutionId: number
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      if (!otp || !institutionId) {
        reject("parameter cannot be empty or invalid");
      }
      this.ewalletWorker = new EWalletWorker(this.configuration, institutionId);
      this.ewalletWorker
        .requestReAuthentication(otp)
        .then((data: any) => {
          return resolve(data);
        })
        .catch((err: Error) => {
          return reject(err);
        });
    });
  }

  authenticateWithEwallet(
    phoneNumber: string,
    institutionId: number
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      if (!phoneNumber || !institutionId) {
        reject("parameter cannot be empty or invalid");
      }
      this.ewalletWorker = new EWalletWorker(this.configuration, institutionId);
      this.ewalletWorker
        .authenticateUser(phoneNumber)
        .then((data: any) => {
          return resolve(data);
        })
        .catch((err: Error) => {
          return reject(err);
        });
    });
  }
  reauthenticateWithOTPEwallletAndLink(
    institutionId: number,
    pin: string,
    url: string
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      this.ewalletWorker = new EWalletWorker(this.configuration, institutionId);
      this.ewalletWorker
        .requestReauthenticationAndLink(pin, url)
        .then((data: any) => {
          return resolve(data);
        })
        .catch((err: Error) => {
          return reject(err);
        });
    });
  }
  authenticatteWithMFABank(): Promise<any> {
    throw new Error("Method not implemented.");
  }

  requestAuthentication(): Promise<any> {
    return new Promise((resolve, reject) => {
      this.accesstokenWorker = new AccessTokenWorker(this.configuration);
      this.accesstokenWorker
        .requestCredentials()
        .then((data: any) => {
          return resolve(data);
        })
        .catch((err: Error) => {
          return reject(err);
        });
    });
  }

  requestAccessToken(): Promise<any> {
    return new Promise((resolve, reject) => {
      this.accesstokenWorker = new AccessTokenWorker(this.configuration);
      this.accesstokenWorker
        .requestAuthentication()
        .then((data: any) => {
          return resolve(data);
        })
        .catch((err: Error) => {
          return reject(err);
        });
    });
  }

  listInstitution(): Promise<any> {
    return new Promise((resolve, reject) => {
      const institutionWorker: IInstitutionPayload = {
        configuration: this.configuration,
        bearerToken: this.configuration.publicAccessToken as string,
        userId: this.configuration.authRequestData?.data
          .clientId as unknown as string,
      };
      this.institutionWorker = new InstitutionWorker(institutionWorker);
      this.institutionWorker
        .listInstitution()
        .then((data: any) => {
          return resolve(data);
        })
        .catch((err: Error) => {
          return reject(err);
        });
    });
  }
  authenticateWithEcommerce(
    username: string,
    password: string,
    institutionId: number
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      if (!username || !password || !institutionId) {
        reject("parameter cannot be empty or invalid");
      }
      this.ecommerceWorker = new EcommerceWorker(
        this.configuration,
        institutionId
      );
      this.ecommerceWorker
        .authenticateUser(username, password)
        .then((data: any) => {
          return resolve(data);
        })
        .catch((err: Error) => {
          return reject(err);
        });
    });
  }
  reAuthenticationWithEcommerce(
    otp: string,
    institutionId: number
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      this.ecommerceWorker = new EcommerceWorker(
        this.configuration,
        institutionId
      );
      this.ecommerceWorker
        .requestReAuthentication(otp)
        .then((data: any) => {
          return resolve(data);
        })
        .catch((err: Error) => {
          return reject(err);
        });
    });
  }
  authenticateWithBank(
    username: string,
    password: string,
    institutionId: number
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      if (!username || !password || !institutionId) {
        reject("parameter cannot be empty or invalid");
      }
      this.bankWorker = new BankWorker(this.configuration, institutionId);
      this.bankWorker
        .authenticateUser(username, password)
        .then((data: any) => {
          return resolve(data);
        })
        .catch((err: Error) => {
          return reject(err);
        });
    });
  }

  authenticateWithIncomeVerification(
    username: string,
    password: string,
    institutionId: number
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      if (!username || !password || !institutionId) {
        reject("parameter cannot be empty or invalid");
      }
      this.incomeVerification = new IncomeVerificationWorker(
        this.configuration,
        institutionId
      );
      this.incomeVerification
        .authenticateUser(username, password)
        .then((data: any) => {
          return resolve(data);
        })
        .catch((err: Error) => {
          return reject(err);
        });
    });
  }

  /**
   * request after get user_access_token
   */
  requestEmploymentDataPastCompanies(userAccessToken: string): Promise<any> {
    return new Promise((resolve, reject) => {
      this.employmentDataWorker = new EmploymentDataWorker(this.configuration,userAccessToken);
      this.employmentDataWorker
        .requestEmploymentDataPastCompanies()
        .then((data: any) => {
          resolve(data);
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }
  requestEmploymentDataGeneral(userAccessToken: string): Promise<any> {
    return new Promise((resolve, reject) => {
      this.employmentDataWorker = new EmploymentDataWorker(this.configuration,userAccessToken);
      this.employmentDataWorker
        .requestEmploymentDataGeneral()
        .then((data: any) => {
          resolve(data);
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }
  requestEmploymentDataEmployent(userAccessToken: string): Promise<any> {
    return new Promise((resolve, reject) => {
      this.employmentDataWorker = new EmploymentDataWorker(this.configuration,userAccessToken);
      this.employmentDataWorker
        .requestEmploymentDataIncomeInformation()
        .then((data: any) => {
          resolve(data);
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }

  /////account 
  requestAccountGeneral(userAccessToken: string): Promise<any> {
    return new Promise((resolve, reject) => {
      this.accountDataWorker = new AccountDataWorker(this.configuration,userAccessToken);
      this.accountDataWorker
        .requestAccountGeneral()
        .then((data: any) => {
          resolve(data);
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }
  requestAccountGeneralMFA(userAccessToken: string): Promise<any> {
    return new Promise((resolve, reject) => {
      this.accountDataWorker = new AccountDataWorker(this.configuration,userAccessToken);
      this.accountDataWorker
        .requestAccountGeneralMFA()
        .then((data: any) => {
          resolve(data);
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }
  requestAccountDetGeneral(userAccessToken: string): Promise<any> {
    return new Promise((resolve, reject) => {
      this.accountDataWorker = new AccountDataWorker(this.configuration,userAccessToken);
      this.accountDataWorker
        .requestAccountGeneral()
        .then((data: any) => {
          resolve(data);
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }

  ////account detail
  requestAccountDetailGeneral(userAccessToken: string,institutionId:string): Promise<any> {
    return new Promise((resolve, reject) => {
      this.accountDataWorker = new AccountDataWorker(this.configuration,userAccessToken);
      this.accountDataWorker
        .requestAccountDetailGeneral(institutionId)
        .then((data: any) => {
          resolve(data);
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }
  requestAccountDetailGeneralMFA(userAccessToken: string): Promise<any> {
    return new Promise((resolve, reject) => {
      this.accountDataWorker = new AccountDataWorker(this.configuration,userAccessToken);
      this.accountDataWorker
        .requestAccountGeneralMFA()
        .then((data: any) => {
          resolve(data);
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }
 

  /////ecommerce
  requestEcommerceBuyerIdentity(userAccessToken:string): Promise<any> {
    return new Promise((resolve, reject) => {
      this.ecommerceDataWorker = new EcommerceDataWorker(this.configuration,userAccessToken);
      this.ecommerceDataWorker
        .requestEcommerceBuyerIdentity()
        .then((data: any) => {
          resolve(data);
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }
  requestEcommerceBuyerTransaction(userAccessToken:string,numberOfTransaction:number): Promise<any> {
    return new Promise((resolve, reject) => {
      this.ecommerceDataWorker = new EcommerceDataWorker(this.configuration,userAccessToken);
      this.ecommerceDataWorker
        .requestEcommerceBuyerTransaction(numberOfTransaction)
        .then((data: any) => {
          resolve(data);
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }
  requestEcommerceMerchantIdentity(userAccessToken:string): Promise<any> {
    return new Promise((resolve, reject) => {
      this.ecommerceDataWorker = new EcommerceDataWorker(this.configuration,userAccessToken);
      this.ecommerceDataWorker
        .requestEcommerceMerchantIdentity()
        .then((data: any) => {
          resolve(data);
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }
  requestEcommerceMerchantIncome(userAccessToken:string,from:string,to:string): Promise<any> {
    return new Promise((resolve, reject) => {
      this.ecommerceDataWorker = new EcommerceDataWorker(this.configuration,userAccessToken);
      this.ecommerceDataWorker
        .requestEcommerceMerchantIncome(from,to)
        .then((data: any) => {
          resolve(data);
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }
  requestEcommerceMerchantTransaction(userAccessToken:string,numberOfTransaction:number): Promise<any> {
    return new Promise((resolve, reject) => {
      this.ecommerceDataWorker = new EcommerceDataWorker(this.configuration,userAccessToken);
      this.ecommerceDataWorker
        .requestEcommerceMerchantTransaction(numberOfTransaction)
        .then((data: any) => {
          resolve(data);
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }

  /////request insight transaction
  requestInsightWorkerAvgBalance(userAccessToken:string,from:string,to:string): Promise<any> {
    return new Promise((resolve, reject) => {
      this.insightWorker = new InsightWorker(this.configuration,userAccessToken);
      this.insightWorker
        .requestAvarageBalance(from,to)
        .then((data: any) => {
          resolve(data);
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }
  requestInsightWorkerBalanceSummary(userAccessToken:string,from:string,to:string): Promise<any> {
    return new Promise((resolve, reject) => {
      this.insightWorker = new InsightWorker(this.configuration,userAccessToken);
      this.insightWorker
        .requestTransactionBalanceSummary(from,to)
        .then((data: any) => {
          resolve(data);
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }
  requestCategorization(userAccessToken:string,categorization:any):Promise<any> {
    return new Promise((resolve, reject) => {
      this.insightWorker = new InsightWorker(this.configuration,userAccessToken);
      this.insightWorker
        .requestCategorization(categorization)
        .then((data: any) => {
          resolve(data);
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }
  requestStatement(userAccessToken:string,month:string,year:string): Promise<any> {
    return new Promise((resolve, reject) => {
      this.statementWorker = new StatementWorker(this.configuration,userAccessToken);
      this.statementWorker
        .requestPDFStatement(month,year)
        .then((data: any) => {
          resolve(data);
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }
  uploadDocumentStatement(userAccessToken:string,filePath:string,userId:string):Promise<any> {
    return new Promise((resolve, reject) => {
      this.statementWorker = new StatementWorker(this.configuration,userAccessToken);
      this.statementWorker
        .extractStatement(filePath,userId)
        .then((data: any) => {
          resolve(data);
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }

  ///// transaction list
  requestTransactionListGeneral(userAccessToken:string,from:string,to:string): Promise<any> {
    return new Promise((resolve, reject) => {
      this.transactionWorker = new TransactionWorker(this.configuration,userAccessToken);
      this.transactionWorker
        .requestTransactionGeneral(from,to)
        .then((data: any) => {
          resolve(data);
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }
  requestTransactionListMFA(userAccessToken:string,from:string,to:string): Promise<any> {
    return new Promise((resolve, reject) => {
      this.transactionWorker = new TransactionWorker(this.configuration,userAccessToken);
      this.transactionWorker
        .requestTransactionGeneralMFA(from,to)
        .then((data: any) => {
          resolve(data);
        })
        .catch((err: any) => {
          reject(err);
        });
    });
  }
}
